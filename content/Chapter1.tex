\chapter{什么是SPICE？}
SPICE，具体地SPICE2G.6，是一个工程设计工具，属于通用模拟电路仿真器类。在同一目录里的工具除了SPICE3，PSPICE，HSPICE，IS\_{SPICE}，MICRO-CAP IV和RSPICE, SABER外，还有许多其他的仿真器。

计算机仿真可以成为传统设计技术的一个强有力补充。在大多数设计策略中，仿真在初期设计开发阶段，比如面包板阶段，调试阶段和诊断阶段，都可以作为一种辅助手段。对于一些电路，初始设计理论在电路设计开始前必须得到测试。有了仿真，电路模块有可能被表示为一种行为元件，以一种功能性的方式被仿真。行为级元件容许设计人员测试电路理论，不用再把时间投入到晶体管开发和各个电路功能的部件级描述中。

对于许多电路来说，面包板是不可能的，因为电路复杂度过高，不同布局不同的寄生效应，或者对于集成电路来说，两种影响都存在。对于这类电路，仿真可能是唯一的方式在构造工作原型前来论证电路行为。

对于大多数电路，元件值的变动会对电路性能和良率产生直接影响。有了仿真，在一个或者更多个电路变量被改变时，设计人员可以有效预测电路的性能。

对于以上这些所有原因，计算机仿真和SPICE在电子电路设计中发挥着越来越重要的作用。

\section{什么是兼容SPICE的仿真器？}
几乎所有的电路仿真器都会读入一个电路文件，该文件描述了电路中的元件类型和要进行的分析类型。处理完这个文件后，仿真器就会进行期望的分析，并且以表格或者图的形式产生输出。

对于所有的可行的模拟电路仿真工具，它们中的绝大部分都是类SPICE或者SPICE兼容的。类SPICE的意思是给定一个电路，仿真器有能力生成一个类似SPICE结果的分析结果，尽管这个类SPICE仿真器可能不能读入一个标准的SPICE电路文件。SPICE兼容的意思是仿真器可以读入SPICE电路文件，执行期望的分析，并且生成标准的SPICE2G.6格式的输出结果。表 \ref{表1.1}展示了几个供应商提供的仿真器的SPICE兼容性。
\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.8\textwidth]{figure/Chapter1/表1.1.png}
    \caption{Vendor-Offered Simulator Compatibility}
    \label{表1.1}
\end{figure}

\section{SPICE的诞生}
讽刺地是，最应该对SPICE开发负责的人却对电路设计或者电路仿真不感兴趣。在1968年，Ron Rohrer, University of California, Berkeley的一位中级教员和电路优化方面的一个结构被安排在网络综合方面开一门课。但是Rohrer深信综合没什么实际用处。Rohrer对电路优化和优化技术更感兴趣。电路优化包括在一个电路上执行多次仿真来研究一个或者多个电路参数改变时输出的变化。直到那时，Rohrer的优化工作因为缺乏一个快速有效的电路仿真器而一直被耽搁。因为电路优化上电路仿真工具的不可行，Rohrer决定用电路仿真的课替代电路综合的课。最终，Rohrer希望开发出一个新的电路仿真器来支持他在优化上的工作 \cite{136783}。
\subsection{CANCER}
在电路仿真课上，Rohrer和12个学生组合了一个非线性电路仿真器，也就是SPICE的基础。这个第一个仿真器被一个叫Larry Nagel的同学命名为CANCER \cite{1050166} （Computer Analysis of Nonlinear Circuits Excluding Radiation）。

CANCER可以完成DC工作点，DC扫描，瞬态扫描和AC扫频分析，这些同样的分析类型今天在SPICE上依然可行。CANCER仿真可能包括电阻，电容，电感和两种非线性器件，结型二极管和双极型晶体管。二极管用Shockley二极管方程建模，双极型晶体管用Ebbers-Moll晶体管方程建模。虽然CANCER在它那个时代是一个杰出的工具，但这个程序的生命因为求解函数无法处理超过400个元件和/或100个电路节点而受到限制。

CANCER并不是1970年代唯一的一款可行的仿真器 \cite{171136}。当时其他的程序还有IBM的ECAP和ECAP-\uppercase\expandafter{\romannumeral2}。BIAS \cite{1050153}和SLIC \cite{1050168} (Simulator for Linear Integrated Circuits) 来源于早期的CANCER。Autonetics,Rockwell的一个分支，在1968年开发出了TRAC \cite{TRAC} （Transient Radiation Analysis by Computer Program）。TRAC是Motorola的TIME和MTIME \cite{SPICE2}程序的基础。TRAC也是Berkeley的SINC程序的基础。
\subsection{SPICE1}
在1970年代，Nagel继续提升CANCER程序。在1971年，这个提升的被命名为SPICE1 （Simulation Program with Integrated Circuit Emphasis）的版本向公众发布。因为Berkeley分销该程序几乎不要钱，所以SPICE1很快就成为了一个工业标准仿真工具。相较于CANCER，SPICE1在几个方面都有提升。双极型晶体管模型被换成了Gummel-Poon模型 \cite{Gummel}。JFET和MOSFET器件根据Shichman-Hodges \cite{1049902}模型加入。SPICE1也提供了一种新的建模方法，也就是宏建模。有了宏模块，工程师可以用重定位电路模板（子电路）的形式描述电路的部分。

在这段时间，集成电路工业的飞速发展加速了SPICE的开发。在很多方面，集成电路和板级电路都是非常不同的。很多IC问题不能用传统的设计技术来检测。正因为此，集成电路的计算机仿真证明了自身是个无价的设计工具。

由于集成电路工业的推动，SPICE中的很多算法针对这些类型的电路进行了优化。这种限制到今天依然存在。虽然SPICE可以被用来仿几乎所有类型的电子电路，但板级电路和带电导或者转换器的电路需要额外的关注，因为许多SPICE算法可能并不适用于这些类型的电路 \cite{Memo}。

\subsection{SPICE2}
程序另一个重要的发布，关于SPICE2，在1975年。SPICE2在SPICE1或者CANCER上有了明显的改进，包括了一种新的对电压定义元件（电导和电压控制电压源和电压控制电流源）电路方程的构造。精度和瞬态仿真速度因为有了两种动态步长控制算法和一种多阶隐式积分方案都获得了提高。为了跟上器件技术的变化，SPICE2的器件模型也进行了提升。从1975年到1983年，Berkeley一直在不断提升和更新SPICE2程序。在1983年，SPICE2 版本G.6（SPICE2G.6）向公众发布。SPICE2G.6是大学发布的最后一款fortran版本的SPICE。（SPICE2G.6目前仍然从Berkeley可以获得。）

\subsection{SPICE3}
CANCER和两代SPICE都是用fortran源码开发的。随着基于Unix的工作站的增长使用，Berkley决定用C来重写SPICE2。这个新的C版本的程序就是SPICE3。

SPICE3是SPICE2的一个超集，包括了SPICE2的所有分析类型和器件模型，还有一些新特征比如提升了的器件模型，电压和电路控制的开关，零极点分析，和一个用来查看仿真结果的图形后处理器。不幸的是，很多70年代早期的激情（和研究资金）已经消失，整个22,000行fortran代码转C的工作交给了少量的几个学生。因为任务的艰巨性，SPICE3A.1的第一个版本里有数十个漏洞和编写错误。更糟糕的是，在fortran和C之间的转换的一些地方，很多SPICE2G.6的功能丢失。SPICE3成为了一个不能后向兼容SPICE2G.6的程序。写这本书的时候，SPICE3F.2是SPICE3最新的版本。尽管Berkeley继续在提升程序，但SPICE3目前还没有完全后向兼容SPICE2。

一些没有被写进SPICE3的特征包括从单个文件运行多个电路网表的能力，多项式控制受控源，多项式电容器和电导器，在线电阻温度系数，电路拓扑错误检查，和温度扫描分析 \cite{SPICE3}。当work-arounds对大多数这些特征都可行的时候，SPICE2的用户可能需要重写旧网表来使它们和SPICE3兼容；这包括了重写旧宏模块来使它们与SPICE3兼容。因为几百个SPICE2的宏模块今天依然可行，也因为与SPICE2兼容的仿真器的大规模安装基础，后向兼容的缺失可能就是SPICE3没能取代SPICE2作为工业标准电路仿真器的压倒一切的原因。

尽管可能没有SPICE2的所有特征，SPICE3提供了几个相对SPICE2的技术优势。SPICE3是用模块C代码编写的，修改起来比用fortran编写的SPICE2要简单。相比SPICE2，SPICE3有着更优的收敛性质。在重写SPICE3器件模型时，几个SPICE2的错误也被发现和纠正了。随着Berkeley继续添加一些加强和对SPICE2的兼容项，SPICE3替代SPICE2的那一天总会到来。但是因为我们绝大多数人都正在使用基于SPICE2的仿真器，这本书会聚焦在SPICE2上。

从1980年到今天，几个供应商提供的SPICE版本出现了。几个比较有知名度的仿真器也是从这个时候开始的，其中包括Meta-Software的HSPICE，IntuSoft的IS\_{SPICE}，Spectrum Software的MICRO-CAP，和MircoSim的PSPICE。所有这些都是基于原本的SPICE2框架开发的。图\ref{图1.1}展示了SPICE2G.6和供应商们提供的仿真器之间的功能性关系。虽然还有许多其他的基于SPICE的程序存在，这四种代表了名气最大的仿真器。尽管少量的供应商提供基于SPICE3的产品，但类SPICE仿真器的全部优势仍然是基于SPICE2G.6的。
\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.8\textwidth]{figure/Chapter1/图1.1.png}
    \caption{兼容SPICE的仿真器的图形表示（来自Successfully Simulating Circuits With SPICE。授权使用）}
    \label{图1.1}
\end{figure}

\section{为什么要仿真？}
你为什么应该仿真你的电路？仿真有什么好处？你听到过太多次这个答案，“电路仿真取代面包板”。没有什么可以超越事实！仿真不能取代面包板；仿真只是补充面包板。很多从仿真学不到的事情可以从面包板处学到，另外仿真也许会揭露很多没准备在实验室学到的东西。

尽管对仿真电路设计可以给出几千个理由，但它们中的大部分都属于下面的四种类型。
\subsection{验证设计理论}
仿真提供在焊线前或者掩模版制作前快速测试电路设计理论的能力。验证一个设计的理论可以在行为模型，宏模型，电路元件（晶体管）模型这些不同层次上进行。

行为模型用数学关系来表示电路模块。用行为的方式，仿真整个系统响应成为了可能。行为模块很容易构建，而且比在元件水平仿电路要快百倍或者千倍。行为模块代表着最高的仿真层次。

宏模型用简化的等效电路来表示电路模块。宏模型电路元件可能包含着真实的电路元件和理想的电路元件（受控电压和电流源）。宏模型仿真比行为模型慢，但比晶体管级模型快得多。因为它们是简化的表示，宏模型不能给出晶体管级仿真那样的良好细节或者精度。

晶体管级仿真是一种简单地对电路中元件的仿真。这种类型的仿真可为任意分析提供最高的精度，但经常伴随着运行时间的问题。晶体管级仿真代表着最低的仿真层次。

在验证电路理论时，设计人员经常从行为级模型开始仿真。随着设计深入和更高精度的要求，宏模型替代行为模型。如果需要更高精度，晶体管级模型会替代宏模型。在许多例子中，一次仿真可能是由行为模型，宏模型和晶体管级模型共同构成，所有的在一次运行完。这种在不同层次上仿真的能力提供给用户一种快速有效的测试设计理论的方法。

\subsection{电路性能和良率分析工具}
仿真容许设计人员在一系列变动的条件，包括温度变化，元件值变化和电源供应变化，中快速测试电路。一旦电路网表建立，电路参数（包括温度，元件值，或者电源供应水平）会被调整和重新仿真。对电路参数的调整能力提供给设计人员在一系列工作条件变化的环境下一种快速有效的测试电路操作的方法。

在现实世界，而不是仿真世界，电阻、电容、电感、晶体管和其他电气部件的值不同的部分都会有变动。即使在最严格的生成控制下，最常见的电气元件的值也有着1\%到5\%或者更多的区域变动。设计人员识别出这个现象并且尝试开发对这些变动不敏感的设计。如何电路的良率依赖元件值的变化，仿真在评估电路良率方面会有用。

当一个或者多个元件值改变时，电路仿真提供给用户一种快速、有效的测试电路性能的方法。通过执行多次仿真和观察每次仿真的输出，元件值变动的极限可以被估算出来，以此来保证电路的功能。图\ref{图1.2(a)}和\ref{图1.2(b)}表明了多次仿真是如何被用来表征电路性能的。
\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.8\textwidth]{figure/Chapter1/图1.2a.png}
    \caption{仿真是研究元件值变动影响的一种有效手段。}
    \label{图1.2(a)}
\end{figure}
\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.8\textwidth]{figure/Chapter1/图1.2b.png}
    \caption{仿真是研究元件值变动影响的一种有效手段。}
    \label{图1.2(b)}
\end{figure}

许多供应商提供的SPICE包现在提供Monte Carlo和最坏情况分析。当执行多次仿真的时候，Monte Carlo和最坏情况分析自动变化电路元件。Monte Carlo和最坏情况分析增强了用户在大量电路参数变动的情况下测试电路性能的能力。

\subsection{评估电路的脆弱性}
计算机仿真给了设计人员不用组合电路就能测试电路的脆弱性的机会。潜行通路条件、信号追赶条件和电源损耗/电源负载条件全部可以通过使用仿真得到快速和简单地验证。虽然很多这些条件可以在面包板上进行测验，但当电路仿真模型被迫超过它们性能的极限时，它们不会像面包板等效那样冒烟、熏烧、产生味道、融化或者爆炸。仿真容许设计人员在对电路或者设计人员无风险的情况下测试电路。

\subsection{失效分析/诊断/预判}
作为一种失效分析工具，电路仿真有一定的局限性。最明显的局限是无法预测与版图相关的寄生参数的行为。SPICE仿真的部件是理想的、无接触的元件。例如，一个CMOS (complementary metal-oxide-silicon) 电路常见的问题是闩锁效应。当N沟道和P沟道晶体管被制作地临近时，闩锁现象就会发生。因为晶体管对中p型和n型硅层会形成一对寄生的双极型晶体管。当寄生的双极型晶体管开始导通电流时，闩锁现象就会发生。如果一个N沟道和P沟道晶体管对在SPICE中被输入，除非把寄生的双极型晶体管也包含在网表中，不然无法观察到闩锁效应。图\ref{图1.3}展示了在一个P阱CMOS反相器中形成的寄生双极型晶体管。试着用SPICE预测这种类型的失效是徒劳的。
\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.8\textwidth]{figure/Chapter1/图1.3.png}
    \caption{在一个P阱CMOS反相器中形成的寄生双极型晶体管。}
    \label{图1.3}
\end{figure}

虽然SPICE不能在不清楚版图相关的寄生效应之前预测它们，但是一旦这些效应清楚了，寄生元件加入网表了，SPICE就可以被用来确定问题的解。在CMOS闩锁效应的例子中，一旦寄生双极型晶体管被识别出是失效的起因，设计人员就会发现调整晶体管的beta（Hfe）会减少或者消除闩锁效应。一旦一个寄生元件被识别为一个问题的起因，仿真可以成为一个决定如何纠正这个问题的快速、有效的方法。

这些只是设计人员转向仿真的一些原因。仿真不能替代面包板。有时候，你从仿真获得的信息和从一个实际的原型获得的并不一样，相反也一样。两个一起使用，面包板和电路仿真器形成了一个必不可少的设计辅助。

\section{哪一个仿真器最好？}
这是一个没有答案的问题。问哪个仿真器最好就像问哪个运放最好，哪个双极型晶体管最好，或者哪个焊料最好。你可以用99美元订购一个IntuSoft的IS\_{SPICE}的复制品，或者你可以用120,000美元订购一个Meta-Software的HSPICE的Cray版本。很明显，在两个程序之间有不同，但也有几处相似。图\ref{图1.1}说明了SPICE2G.6和几个供应商提供的仿真器之间的功能性关系。功能上讲，大多数兼容SPICE的仿真器都是SPICE的超集，这就意味着在SPICE2G.6上运行的电路网表也可以在HSPICE、IS\_{SPICE}、MIRCRO-CAP \uppercase\expandafter{\romannumeral4}或者PSPICE上运行，但是反过来不成立。用HSPICE特定的功能和特征的电路不能在SPICE2G.6上运行，也不可以在PSPICE、MICRO-CAP、或者IS\_{SPICE}上运行。

你应该问的问题是，“哪一款仿真器最适合我的设计需要？”当然，SPICE2G.6仍然可以花150美元（只有源码）从Berkeley订购。但是许多供应商提供的程序可以提供在Berkeley SPICE之上的优势和能力。一些供应商提供的工具中加入的特征包括改善的器件模型、Monte Carlo和最坏情况分析、零极点分析、网络分析、规模参数和功能、自动优化、器件模型库和热线支持。虽然很多这些供应商提供的工具中加入的特征之间有重叠，但是很多特征对于任一个兼容SPICE的仿真器都是唯一的。寻找最能符合你的设计需求的特征。唯一能决定用哪个仿真器最好的是你设计的方法。

\subsection{一个字，钱}
和大多数自由市场的商品一样，你为一个仿真器付的钱取决于添加在这个程序中的特征和能力、供应商期待卖出的复件个数（个人计算机软件通常卖的不如工作站软件因为个人计算机市场要大的多）、和你运行这个程序的机器速度。最后一个原因也许看起来有一点奇怪。许多软件公司已经同意在一台更快的计算机上运行仿真器意味着可以更快地获取结果，或者用它们的软件可以更多产。正因为此，许多软件代理商基于计算机的速度调整工具的价格。买的时候多看看。你也许会发现你可以因为你用的计算机类型省下不少钱。

\section{你想对什么进行仿真？}
在大多数基本格式里，仿真要求一个文本编辑器来创建一个输入文件和一个仿真程序。最小的机器推荐是386 PC （带协处理器）。至于仿真程序和编辑器，MS-DOS编辑器（EDIT）是一个非常简单的创建你的第一个输入文件的方法。

如果你用一台PC仿真，你起步用的仿真器应该是一个32位版本的SPICE。SPICE在整个程序中使用64位的数学格式。许多早期的SPICE PC版本是16位的。移动一个单节点电压或者支路电流要4次内存转移。一个32位程序的数据转移速度几乎是16位版本SPICE的两倍；正因为此，一个32位版本的SPICE执行起来要比16位版本的快的多。当然16位版本的SPICE可以在任意的PC（从pcXT到486s）上运行，但是32位的程序只能在386sx、386dx、486和更高级的CPU上运行。伴随这个文本的RSPICE和RGRAPH是32位程序。问你的仿真代理商他们的程序是32位还是16位版本的。

但是接下来的段落只会描述一些基础。如果你只用一个仿真器和编辑器开始的话，你会很快意识到精确仿真需要精确的元件模型和精确的器件模型参数。任何代理商提供的SPICE版本中最重要的加入的特征之一就是常见电器元件库。双极型晶体管、二极管、运放、和几千个其他器件模型可以被存放在一个库里，在需要的时候被调入仿真器。当然，你可以开发你自己的器件模型，但是开发精确的元件模型和模型参数会是一个费钱耗时的过程。

不管你从库里得到器件模型还是自己开发它们，在你获得准确、可靠、有意义的结果前，你需要知道如何使用你的仿真器。使用你的仿真器意味着学会如何用SPICE的语法组装输入文件，学会如何避免不收敛的问题，步长控制，和数值积分不准确。SPICE新手常掉入的一个陷阱是认为仿真输出总是正确的。SPICE经常会无法收敛到一个解上，或者更糟的，会收敛到一个错误的解上！数值积分和步长控制问题会导致不精确的解。尽管SPICE程序已经有20年了，但我们仍在学习哪些数值算法工作地好和哪些工作地不好\cite{SPICE3}。

高质量仿真的最终决定因素是用户的教育程度。为了实现精确有效仿真，学习如何克服不收敛的问题，学习判断仿真输出是正确的还是错误的，以及学习诊断仿真疾病是必须要掌握的课程。

这三个要素-一个好的仿真器、精确的模型、和好的用户技术-就像三脚架的腿一样。没有哪个要素比另外的哪个更重要。没有好的仿真器、精确的器件模型和好的用户技术，仿真结果就是简单的虚构数字。

\section{仿真的一些障碍}
前面的段落都在讲SPICE有多好，事实是，基本上在使用这个程序时，用户会有很多问题。SPICE不是一个傻瓜式设计辅助工具。多少年来，作者的工作就是帮助很大的设计社区的工程人员学习使用SPICE。尽管在用几个基于SPICE的包，包括SPICE2G.6，很多仿真还是会遭遇不收敛问题、步长控制异常、和数值积分错误。对很多设计人员来说，仿真的障碍是无法同时确定意外仿真结果的起因和纠正这一结果。

这本书的标题起的很恰当，在SPICE中：克服电路仿真的障碍。仿真障碍是指使仿真器失效的事情，像无法收敛；是指使仿真器产生错误答案的事情，像步长控制问题；也是使仿真器产生意外结果的事情，像数值积分不稳定。很多设计人员没有意识到SPICE会犯错，更少有人知道发生错误后如何纠正。这些才是电路仿真中的真正障碍，当然这些也是本书试图解决、识别和纠正的问题。

\section{总结}
SPICE是设计/分析必不可少的一个工具，但，像任何工具一样，SPICE有局限。即使是最好的工具在一些没有经验的用户手里也会变得无效。SPICE是一个复杂的设计工具。你不能简单地把一个网表和器件模型扔给一个仿真器，然后期待正确的结果。像一个木匠非常有技巧地做一件精巧的家具，仿真用户会小心地对给定的电路和分析类型选择合适的仿真器选项。精确的仿真结果并不是偶然碰上的。你选择的器件模型和仿真器选项都会决定你的结果的速度、精度、和效率。

这本书专门聚焦在SPCIE2G.6的算法上。因为大多数类SPICE仿真器是基于SPICE2G.6的算法，这本书中提到的几乎所有东西可以直接应用到类SPICE仿真器上。虽然很多供应商已经在原2G.6算法上增加了修正，但没有一个类SPICE仿真器已经完全消除了不收敛问题、步长控制问题、或者数值积分问题。出于这些原因，理解为什么这些问题会出现和它们如何可以被最小化或者消除，对SPICE的所有用户都是重要的。本书中出现的所有解都是以标准的用户选择的SPICE控制的格式，而且大多数类SPICE仿真器有着相同的控制。本书的目标是教会如何定制仿真器的控制参数来提高仿真结果的速度和精度；从这里学的内容可以应用到今天每一个可行的类SPICE仿真器上。

\bibliographystyle{plain}
\bibliography{Reference/chapter1-reference}