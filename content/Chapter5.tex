\chapter{时间步长控制}
\label{chap:5}

时间步长控制算法决定SPICE在哪些时间点上求解电路方程。时间点的选择与数值积分函数的精度直接相关，与仿真器的收敛性质没有直接关系。出于这些原因，SPICE的时间步长控制算法是瞬态仿真中最重要的函数。但是与SPICE中的其他许多函数一样，时间步长控制算法并不是万无一失的。精确的，高质量的瞬态仿真要求对时间步长控制函数进行精准裁剪。

本章会一窥SPICE中的两种时间步长控制算法。像数值积分一样，每种算法有优势也有劣势，每种算法在特定类型的电路上工作良好，而每种算法也都会遇到一系列专有的问题。在特定电路上知道使用哪种时间步长控制算法和知道每种算法的限制是成为一名真正仿真工匠的下一堂课。

\section{早些年的时间步长控制}
在1960年代晚期和1970年代早期，当CANCER和SPICE1被用来仿真电路时，瞬态命令：

.TRAN 1NS 100NS

强迫仿真器在每1nS时间间隔求解一次电路方程。这个被称为恒定时间步长控制。有了这个命令，CANCER和SPICE1在瞬态仿真中都求解电路方程并每隔1nS打印一次输出结果。图\ref{图5.1a}展示了常时间步长控制仿真。对于这些早期仿真器，打印间隔和内部时间点是一致的。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.1a.png}
    \caption{(a)常数时间步长控制仿真}
    \label{图5.1a}
\end{figure}

但是在用一个恒定比例扫描时间步长时，立马能看到两个问题。第一，带大的，快速的电压和电流转换的电路经常在开关点处收敛失败。（这与那个引起直流扫描分析在电压转换附近失效的不收敛机制是同一个。在第\ref{chap:non-conver}章可看到关于这个为什么会发生的详细讨论。）只有显著地减小步长尺寸，仿真才会成功地穿过电压转换。但是小时间步长产生极长的仿真时间，而且会加重不收敛问题。关于恒定时间步长控制的第二个问题与数值积分算法相关。有了恒定时间步长尺寸，当电路处于稳定状态时，数值积分算法产生最精确的结果，而当电路处于转换状态时，积分函数产生最低精度的解。有了恒定步长尺寸，数值积分算法引入的误差正比于电路电压和电流的转换率。对于电路仿真，恒定时间步长控制强迫用户在慢的（长运行时间）精确的仿真和快的不精确的仿真之间做出选择。

\section{提升时间步长控制算法}
SPICE2的引入给电路仿真带来了两种不同形式的动态时间步长控制。当电路趋于电压或者电流转换时，两种时间步长控制算法减小步长尺寸，随后当电路再次开始稳定时，增加步长尺寸。这些动态时间步长控制算法在本质上要好于简单的恒定时间步长控制，而且明显同时提高了瞬态仿真的精度和速度。

但是，像数值积分算法一样，没有一种时间步长控制算法是完全可以信赖的。在特定类型的电路上，两种时间步长控制函数都有问题，并且这些问题会在仿真输出中引入明显的误差。即使有完全精确的器件模型，时间步长控制算法中的失效机制会给仿真结果中引入明显的误差。有经验的仿真用户关心这些可能的问题，而且当有问题的仿真结果出现时，知道应该使用的纠正措施。


\section{动态时间步长控制回顾}
SPICE中的两种时间步长控制算法都有着本质上相同的目的。时间步长控制算法必须这样调整步长尺寸，在快速电压转换时期，为了在通过转换区时避免不收敛和保持精度，时间步长得减小，而在很少或者没有电路活动的时期，为了加速仿真得到解，时间步长得增加。但是两种时间步长控制算法之间的微小差异会整体带来明显不同的仿真结果。

虽然动态时间步长控制算法明显地改变了SPICE计算瞬态仿真点的方式，但是当时间步长控制函数被改变时，瞬态命令却没有变。这导致了些许令人困惑的地方。瞬态命令

.TRAN 1NS 100NS

看起来仍然像暗示着SPICE在按均匀间隔1nS来求解瞬态仿真。这条命令与使用恒定时间步长控制函数的早期CANCER和SPICE1版本一模一样。动态时间步长控制函数没有按均匀间隔来求解电路方程。时间步长控制函数执行的任务是决定电路方程应该在哪里被求解。瞬态分析开始后，SPICE使用方程(\ref{eq:5.1})来计算第一个瞬态时间点。当程序计算完第一个时间点，时间步长控制算法确定增加或者减小时间步长尺寸的责任。

\begin{equation}
    STEP(1)=\frac{transient\ duration}{50}
    \label{eq:5.1}
\end{equation}

随着SPICE继续进行瞬态仿真，时间步长控制算法检测和调整时间步长的尺寸。在每一个计算过的时间点上，SPICE把解保存到内存中。瞬态仿真结束时，SPCIE用简单的线性插值函数和从瞬态仿真中存储的数据来产生均匀分布的1nS输出结果。图\ref{图5.1b}展示了动态时间步长控制仿真。在大多数仿真中，SPICE在瞬态仿真期间求解的时间点数目比输出点的数目要多的多。1nS打印间隔对时间点值的选择几乎没有影响。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.1b.png}
    \caption{(b)动态时间步长控制仿真。动态时间步长控制同时通过采样更少的时间点增加仿真速度，而通过采样更多需要的时间点增加仿真精度。SPICE提供给用户两种类型的动态时间步长控制。当使用动态时间步长控制，输出文件中打印的值由两个临近的解点插值得到。打印间隔对解点的选择几乎没有影响。}
    \label{图5.1b}
\end{figure}

SPICE中的时间步长控制算法都使用了三种传感器来控制时间步长的尺寸。传感器监测电路电压和电流的变化率，不收敛时间点，以及电源断点。当然，第一个，变化率传感器，是影响时间步长选择的决定性机制。其他的传感器修正变化率传感器预测的时间步长。除了控制传感器，时间步长控制算法在时间步长的尺寸上也有上界和下界。所有这些机制一起工作来为仿真预测最好的时间步长。

\subsection{时间步长控制和电路活动}
两种时间步长控制算法都有测量电路电压和电流变化率的方法，而这种测量方法被用来增加或者减小现在的时间步长。在电压和电流转换期间，时间步长被减小，而在较少电路活动期间，时间步长被增加。每一种时间步长控制算法都使用不同的测量方法来确定电路的变化率。其中一种算法监测在每个新解点上的迭代次数。在快速电路转换期，为了实现收敛，电压和电流水平要求更多的Newton-Raphson迭代。当迭代次数增加，时间步长会被减小。在延迟期，只需要非常少的迭代，因为电路电压不在改变。在这些条件下，时间步长会被增加。随着分析继续进行，步长尺寸基于前一个时间点处的迭代次数会被调整。另一个算法使用的函数是通过监测数值积分函数产生的误差的量。在很少或者无电路活动的时期，数值积分函数相当精确，产生不了什么误差。因为误差小，时间步长控制算法会增加步长尺寸。当电路活动增加，误差也会增加，而这会迫使时间步长控制算法来减小时间步长。在整个瞬态分析中，变化率传感器监测电路活动，并对时间步长做出合适的调整。

\subsection{时间步长控制和不收敛时间点}
两种时间步长控制算法测量收敛到解点需要的迭代次数。如果给定的时间点在ITL4次迭代内收敛到解失败，两种时间步长控制算法会丢弃失败的时间点，把前一个时间步长减小到原值的$\frac{1}{8}$，然后重新尝试在靠近上一个收敛时间点的附近时间点上求解。Nagel等人\cite{chap5-1}确定，当瞬态仿真在一定迭代次数内收敛失败时，失败通常可以归功于快速电压转换。正因为此，Nagel把时间步长减小到了原值的$\frac{1}{8}$，并且在新的时间点上重新尝试求解。图\ref{图5.2}展示了SPICE在收敛失败后如何重新计算一个新的时间点。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.2.png}
    \caption{一个不收敛时间点之后重新尝试求解一个新解。}
    \label{图5.2}
\end{figure}

丢弃不收敛时间点和重新尝试求解新解对直流工作点和直流扫描解算法来说都是一个明显的提升。只有在瞬态分析中，找到一个不收敛时间点后，仿真器才会继续搜索解。SPICE会通过不断减小时间步长来持续搜索新解，直到要不仿真器收敛，要不时间步长尺寸被减到了一个容许的最小值之下。只有当后面那种情况发生时，SPICE才会中止解算法，并且打印警告信息“内部时间步长太小”。

\subsection{时间步长控制和电源断点调整}
脉冲和PWL（分段线性）电路电源都会产生带尖锐前沿和后沿边的脉冲波形。经常，电源状态的改变，比如前沿边或者后沿边，是电路转换的先兆。正因此，SPICE在瞬态仿真开始前会产生一个断点列表。该表包含了对应脉冲或者PWL电源每条上升或者下降边的起始和结束时间点。在瞬态分析中，SPICE迫使时间步长控制算法在每个断点处求解电路，并且在断点计算后自动减小时间步长。强迫仿真器在电源断点处求解电路极大地增加了瞬态输出的精度。图\ref{图5.3}展示了一个脉冲电压源的断点。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.3.png}
    \caption{一个脉冲电压源的电源断点。}
    \label{图5.3}
\end{figure}

\subsection{最小和最大时间步长}
每一个时间步长控制算法都对时间步长的尺寸有一个上界和下界。在长时期的延时中，时间步长控制算法继续试着增加时间步长。时间步长会被增加直到容许的最大步长尺寸。即使没有电路活动，时间步长也不会超过这个最大限制。如果解点收敛失败，SPICE会把时间步长的尺寸减小8倍，然后重新尝试求解电路。如果新的时间点也收敛失败，时间步长会被再次减小8倍。这个过程会一直持续到找到一个收敛的解或者时间步长等于或小于最小值的时间步长。如果时间步长被减到了容许的最小值以下，SPICE会打印“内部时间步长太小”的错误信息，并且中断仿真。

对两种时间步长控制算法来说，刚才描述的机制决定了时间步长的尺寸和SPICE在哪里试着求解电路方程。变化率传感器选择对电路合适的时间步长。如果新解点收敛失败，时间步长会被减小8倍，然后重新求解。如果时间步长靠近电源断点，步长尺寸会被调整到与断点对齐。仿真的非活跃期会增加时间步长到容许的最大限制，或者不收敛问题会减小时间步长到容许的最小限制并中止仿真。这些是在瞬态仿真中确定步长尺寸的机制。

\section{迭代次数时间步长控制}
两种时间步长控制算法中的第一种是迭代计数方法。该名字来自SPICE监测电路活动的途径。

在瞬态仿真中，迭代计数时间步长控制算法在每个时间点监测迭代次数。当电路处于一个稳定的条件下时，在每个新时间点求解电路方程需要的迭代次数通常比较小。当迭代次数比更低的阈值（ITL3）还要小的时候，时间步长控制算法在计算下一个时间点前会加倍时间步长的尺寸。少的迭代次数预示着电路相对不活跃，因此需要使用一个大一些的时间步长。

当电路开始进入转换或者电路活动开始增加，每个时间点处的迭代次数也会增加。当迭代次数超过上限（ITL4），时间步长控制算法会丢弃当前的时间点，并把时间步长切到当前值的$\frac{1}{8}$，然后重新用更小的时间步长尝试求解。

如果电路进入延时阶段并且迭代次数比ITL3小，时间步长控制函数会试着增加时间步长。如果电路停留在延时阶段，时间步长控制会持续增加步长尺寸直到时间步长的尺寸到达它的最大限制。有了迭代计数方法，时间步长会被限制得不能比瞬态声明中特定的打印间隔大。对于迭代计数方法，打印间隔决定了最大时间步长。

如果当前时间点收敛失败，时间步长会被减到之前值的$\frac{1}{8}$，然后在新的时间点重新尝试求解。如果新时间点还是失败，时间步长会再次被切。这个过程会一直持续直到要不找到了收敛的时间点，要不步长尺寸被减到了容许的最小值之下。对于迭代次数时间步长控制算法，容许的最小步长尺寸是TSTOP/50e9，这里TSTOP是瞬态分析的持续时间。

迭代次数时间步长控制算法通过一个较高的和一个较低的阈值来调整时间步长。当迭代次数比较高的阈值，ITL4，大的时候，时间步长会被减小8倍。当迭代次数比较低的阈值，ITL3，小的时候，时间步长会被增加2倍。迭代次数算法调整时间步长以此来保证每个时间点上的迭代次数在这两个阈值之间。

不管电路活动（或者不活动），时间步长从来不会被容许比打印间隔还大。如果时间步长被减到了容许的最小值之下，SPICE会打印“内部时间步长太小”的错误信息，并中止仿真。

ITL3和ITL4都是SPICE的选项，并且可以被用户调整。ITL3默认被设置为4次迭代，而ITL4被默认设置为10次迭代。迭代计数时间步长控制算法可以通过设置选项LVLTIM为1来选择。

\section{局部截断误差时间步长控制}
第二种时间步长控制类型是局部截断误差时间步长控制算法。局部截断误差方法是SPICE和大多数类SPICE仿真器使用的默认方法。局部截断误差函数使用了一个公式，该公式预测了在前一个时间点的数值积分计算中计算出的误差幅度。局部截断误差时间步长控制算法使用数值积分函数中产生的误差量来调整时间步长。方程(\ref{eq:5.2})展示了与计算得到的局部截断误差和时间步长相关的方程。方程(\ref{eq:5.2})中的LTE表达式是计算得到的局部截断误差。随着截断误差增加，时间步长减小；随着截断误差变小，时间步长增加。这个算法保持的时间步长使得在数值积分函数中的误差量被控制在一个容许的限制内。

\begin{equation}
    STEP(T+1)=\sqrt{\frac{TRTOL*(RELTOL*|I_c(T)|+ABSTOL)}{MAX(ABSTOL, LET(T))}}
    \label{eq:5.2}
\end{equation}

在方程(\ref{eq:5.2})中，计算得到的局部截断误差会被选项ABSTOL，RELTOL，和TRTOL缩放。ABSTOL和RELTOL是在第\ref{chap:non-conver}章提出的收敛误差容限选项；TRTOL会在本章的稍后讨论。方程(\ref{eq:5.2})重新展示了对电路中的电压和电流，把误差容限参数设置到合适水平的重要性。对ABSTOL和RELTOL的不合理的设置会迫使SPICE在瞬态仿真中使用不是一般小的时间步长。虽然小的时间步长会有助于确保仿真的精度，但是过小的时间步长会引起长时间的运行以及可能加重不收敛问题。

除了局部截断误差变化率传感器，局部截断误差时间步长控制算法在一个给定的时间点也使用ITL4作为迭代次数的限制。如果在一个时间点处的迭代次数超过ITL4，时间步长控制算法就会把时间步长砍到原值的$\frac{1}{8}$，并在新的时间点上重新尝试求解。

随着电路活动减少，由数值积分函数引入的局部截断误差也会减少。随着局部截断误差减少，时间步长控制函数会试着增加时间步长。如果电路保持稳定，时间步长控制函数继续增加步长尺寸，直到步长尺寸到达被容许的最大极限。对于局部截断误差时间步长控制函数，容许的最大时间步长是TSTOP/50，这里TSTOP是瞬态仿真的持续时间。

如果当前时间点收敛失败，时间步长会被减到前值的$\frac{1}{8}$，并在新的时间点上重新尝试求解。如果新时间点也收敛失败，时间步长会再次被砍。这个过程会一直持续直到要不找到一个收敛的时间点，要不步长尺寸被减到了容许的最小值以下。对局部截断误差时间步长控制算法，容许的最小步长尺寸为TSTOP/50e9，这里TSTOP为总共的瞬态持续时间。SPICE中的两种时间步长控制算法使用的是同一个最小时间步长限制。

局部截断误差时间步长控制算法是SPICE中默认的算法。局部截断误差方法通过选项LVLTIM=2选中。

\section{时间步长控制算法对比}
虽然两种时间步长控制算法都是好的，但局部截断误差算法应该可以产生出更精确的瞬态分析，因为在数值积分截断误差和时间步长尺寸之间有着亲密的耦合关系。迭代计数法没有对数值积分误差测量，因为无法根据这个误差来调整时间步长。

但是如果对局部截断误差的估计是准确的，那么局部截断误差算法只会提供更优的结果。SPICE用来计算局部截断误差的公式被称为三阶差分公式（Third Divided Difference formula）\cite{chap5-1}。实验上，Nagel等人注意到从三阶差分公式预测的局部截断误差是真实值的7倍左右。出于这个原因，Nagel给局部截断误差增加了TRTOL选项（方程(\ref{eq:5.2})）。TRTOL被默认设置为7。即使有了这个纠正因子，对于特定类型的电路，对局部截断误差的估计还是极其糟糕的。对正弦电路和电感电路，三阶差分公式和方程(\ref{eq:5.2})给出的关于时间步长的估计极其糟糕。正因为此，当用迭代计数时间步长控制算法来仿真时，这两种类型的电路会产生更好的结果。

即使对局部截断误差的估计时准确的，在局部截断误差时间步长控制算法中还存在着第二种失效机制。局部截断误差时间步长控制算法限制最大时间步长为TSTOP/50，这里迭代计数时间步长控制算法限制最大时间步长为TSTEP。

TSTEP是打印间隔，而TSTOP是瞬态持续时间。对有超过50个解点的电路来说，局部截断误差时间步长控制算法容许时间步长变得比打印间隔大得多。对要进行几百次或者几千次解点仿真来说，局部截断误差时间步长控制算法会使用比打印间隔大得多的步长尺寸。当这种情况发生，仿真结果就是下采样的或者变样的，而输出就表现为带波浪的和扭曲的。

\section{时间步长控制失效}
图\ref{图5.4}是一个200-MHz正弦振荡器的原理图。硬盘文件ch5-5a.cir包含电路的列出。用下面的命令在RSPICE中仿真这个电路：

SIM CH5-5A.CIR

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.4.png}
    \caption{电路文件ch5-5.cir的电路原理图。}
    \label{图5.4}
\end{figure}

你的结果应该和图\ref{图5.5a}匹配。
\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.5a.png}
    \caption{(a)重印自Successfully Simulating Circuits With SPICE。授权使用。}
    \label{图5.5a}
\end{figure}

在这个仿真中，默认的时间步长控制算法（局部截断误差）容许步长尺寸变得太大了，以致于不能精确地仿真电路。对正弦波形，局部截断误差测量经常是糟糕的，而且导致对步长尺寸的错误估计。局部截断误差时间步长控制算法容许时间步长增加到整个仿真持续时间的$\frac{1}{50}$（在这个例子中是4nS）。对于一个200-MHz的信号，4nS比最坏情况的Nyquist标准2.5nS要大的多。这个200-MHz的信号被下采样了！

现在用下面的命令仿真电路文件ch5-5b.cir：

SIM CH5-5B.CIR

你的结果应该和图\ref{图5.5b}匹配。在这个仿真中，.OPTION LVLTIM=1指导SPICE使用迭代计数时间步长控制算法。注意仿真结果中的提升。迭代计数时间步长控制算法限制仿真步长不能超过打印间隔TSTEP（在这个例子是.2nS），并且，对于该电路，消除了下采样引起的扭曲。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.5b.png}
    \caption{(b)局部截断误差时间步长控制算法容许时间步长变得比打印间隔大的多。切换到迭代计数法或者手动限制HMAX参数可纠正问题。(重印自Successfully Simulating Circuits With SPICE。授权使用。)}
    \label{图5.5b}
\end{figure}

\subsection{限制最大步长尺寸}
尽管局部截断误差时间步长控制算法的最大步长尺寸的默认限制为TSTOP/50，但用户也可以手动限制最大步长尺寸。

.TRAN TSTEP TSTOP <TSTART> <HMAX>

无论哪种时间步长控制算法的最大步长尺寸都可以通过瞬态声明的HMAX参数手动限制\cite{chap5-2}。两种时间步长控制算法要不使用默认的最大时间步长，要不使用HMAX（哪个更小）作为最大瞬态步长尺寸。

现在用命令仿真电路文件ch5-5c.cir：

SIM CH5-5C.CIR

你的结果应该再次和图\ref{图5.5b}匹配。在这个仿真中，（默认的）局部截断误差时间步长控制算法的最大步长尺寸用命令被限制为打印间隔（HMAX被设置得与TSTEP匹配）：

.TRAN .2NS 200NS 0 .2NS

再次注意相对初始仿真结果的提高。也要注意如果要设置HMAX，必须用一个数值填补TSTART的位置！

那些对TSTART参数不熟悉的用户需要知道，TSTART指定了SPICE开始打印输出结果的瞬态仿真时间。TSTART并不是SPICE开始仿真的时间。（瞬态分析一般在时间T=0处开始。）

用下面的命令仿真硬盘文件ch5-5.cir：

RSPICE CH5-5.CIR

之后用命令绘制结果：

RGRAPH CH5-5.OUT CH5-6.MAC /MULTI /MARKERS

你的结果应该和图\ref{图5.6}匹配。在这个仿真中，分别对振荡器电路进行带和不带HMAX限制的仿真。两个结果被叠加在一起以便比较。注意没有步长尺寸限制的仿真是如何下采样正确输出的。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.6.png}
    \caption{时间步长控制失效和纠正的仿真。(重印自Successfully Simulating Circuits With SPICE。授权使用。)}
    \label{图5.6}
\end{figure}

对很多仿真，使用带被设置为打印间隔的HMAX的局部截断误差时间步长控制或迭代计数，会产生几乎一致的结果。有些仿真会要求HMAX被设置得比打印间隔还小；有些仿真即使HMAX被设置得比打印间隔还大也会产生精确的结果。根据大多数仿真得到的一个好的经验是把HMAX设置得与打印间隔相等。作为一种误差防范措施，通常在瞬态声明中设置HMAX参数来帮助最小化时间步长控制问题。

\subsection{断点调整的限制}
除了在电路活动变化时调整步长尺寸，以及限制步长尺寸到一个最大的值，SPICE也把解时间点与电源的断点对齐。随着瞬态仿真开始接近断点，时间步长控制算法调整时间步长以使得下一个解点落到下一个断点上。为了进一步增强刚过断点后的精度，时间步长控制算法在紧接着电压或电流转换的断点之后自动减小时间步长。对很多电路，带断点调整的时间步长控制明显提高了仿真结果的精度。

虽然断点调整在很多电路上运行良好，但是当步长尺寸变得太大的时候，时间步长控制算法会错过一个或者多个电源断点。图\ref{图5.7}是一个SR触发器和测试生成器的原理图。硬盘电路 ch5-8a.cir包含了电路列表。脉冲生成器使用短脉冲来设置和重置触发器。用下面的命令仿真电路：

SIM CH5-8A.CIR

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.7.png}
    \caption{电路文件ch5-8.cir的电路原理。}
    \label{图5.7}
\end{figure}

你的结果应该和图\ref{图5.8a}匹配。被用来设置和重置锁存器的脉冲如图\ref{图5.9}所示。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.8a.png}
    \caption{(a)在这个仿真中，时间步长控制算法跳过了几个电源断点。(重印自Successfully Simulating Circuits With SPICE。授权使用。)}
    \label{图5.8a}
\end{figure}

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.8b.png}
    \caption{(b)断点监测算法跳过短持续时间的脉冲。对这些类型的电路，精确的仿真会要求限制HMAX参数。(重印自Successfully Simulating Circuits With SPICE。授权使用。)}
    \label{图5.8b}
\end{figure}

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.9.png}
    \caption{从上升边开始到下降边结束，同步脉冲是750nS。只有微秒级别的瞬态持续时间，这种小同步脉冲很容易被断点监测算法错过。对这种类型的电路，设置最大时间步长是关键。}
    \label{图5.9}
\end{figure}

在这个仿真中，短脉冲的断点会被时间步长控制算法跳过。图\ref{图5.9}展示了从上升边开始到下降边结束，设置和重置脉冲只持续了750nS。因为设置和重置脉冲的短持续时间，以及大的时间步长，时间步长控制算法错过了断点，完全跳过了设置和重置脉冲。结果，触发器从来没有接收到过设置或重置信号。

这是在包含短脉冲的仿真中一种相当常见的事件。短是一个相对项。更一般的描述是：任何带有总持续时间小于仿真的最大时间步长的$\frac{1}{100}$的电压或电流脉冲的电路会在瞬态仿真中因为断点调整而遭到问题。

对于使用短脉冲的电路，把最大时间步长设置得不要超过最小脉冲持续时间的50倍。这会帮助确保断点调整算法会监测到电源断点的存在，并对时间步长做出相应调整。

在ch5-8电路的例子中，脉冲持续时间是750nS（250nS上升+250nS下降+250nS持续）。对于这个电路，上述规则声明的最大时间步长应该是：

50 * 750nS = 37.5$\mu$S

电路文件ch5-8b.cir与原电路文件完全一致，除了在瞬态声明中加入的HMAX参数。在瞬态声明中，HMAX被设置为37.5$\mu$S。用下面的命令仿真ch5-8b.cir电路文件：

SIM CH5-8B.CIR

你的输出应该和图\ref{图5.8b}匹配。

一个精明的读者也会识别出带短上升和下降时间的长脉冲波形也会遇到断点问题。虽然这是正确的，有短上升和下降时间但是长脉冲持续时间的脉冲带来的问题比短脉冲持续时间的脉冲带来的要少。想象一个带有非常短上升时间的长脉冲。尽管SPICE会错过上升边电源断点，但是如果脉冲持续时间长，下一个时间点就会发生在电源的脉冲值上。所以虽然时序也许会稍微关闭，但是仿真不会整个跳过脉冲。对那些对上升边和下降边时序要求严格的电路，把最大时间步长设置到不超过50*(上升时间)或者50*(下降时间)，来确保上升边和下降边的断点能被找到。

\section{典型电路的时间步长控制设置}
前面的电路例子展示了SPICE时间步长控制算法中常见的问题。表\ref{表5.1}总结了SPICE中不同的时间步长控制算法之间的差别。表\ref{表5.2}描述了一系列指导原则，这些指导原则应该被用来选择时间步长控制算法和最大步长尺寸。用表\ref{表5.2}来选择时间步长控制算法和最大时间步长会消除大部分由时间步长控制算法引起的问题。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter5/表5.1.png}
    \caption{SPICE时间步长控制算法总结}
    \label{表5.1}
\end{figure}

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.7\textwidth]{figure/Chapter5/表5.2.png}
    \caption{带最大时间步长推荐的一般时间步长控制算法设置}
    \label{表5.2}
\end{figure}

\section{时间步长控制和振荡器电路}
振荡器电路是一类特殊类型的电路，对两种时间步长控制算法都提出了独特的问题。在振荡器仿真的起始阶段这是特别真实的。

图\ref{图5.10}是一个简单的Colpits振荡器。硬盘文件ch5-11a.cir是该振荡器的列表。用下面的命令仿真该电路：

SIM CH5-11A.CIR

你的结果应该和图\ref{图5.11a}匹配。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.10.png}
    \caption{电路文件ch5-11.cir的电路原理。}
    \label{图5.10}
\end{figure}

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.11a.png}
    \caption{(a)（重印自Successfully Simulating Circuits With SPICE。授权使用。）}
    \label{图5.11a}
\end{figure}

在这个电路中，SPICE预测振荡器的起始阶段失败。SPICE预测振荡器失败的原因与时间步长控制算法的操作相关。

大多数真实的振荡器开始振荡是因为电路中有微弱的电压和电流涌动（噪音）。SPICE也会以舍入误差的形式产生微量的电压和电流噪声。程序的误差容限选项（RELTOL，VNTOL，和ABSTOL）决定了舍入误差噪声的幅度。所以为什么振荡器不开始振荡？振荡器启动失败因为对于使用的时间步长尺寸来说，电压涌动没有大到可求解电路的地步。

假定程序的电压误差容限被设置为1$\mu$V（.OPTION VNTOL=1$\mu$V）。在每个时间点上数值噪声的最小量是$\pm 1\mu$V。在每个时间点上的电压涌动是$delta_V/delta_T$或者1$\mu$V/timestep。当瞬态仿真开始，SPICE计算得到的输出电压非常接近0 volts。振荡还没有开始。随着瞬态仿真进行，步长尺寸增长很快，因为时间步长控制算法在输出上没有检测出变化。当步长尺寸持续增加，数值噪音（dV/dt）的值减小，因为那个1$\mu$V电压现在被越来越大的时间步长除了。循环继续。时间步长控制算法增加时间步长因为振荡没有开始，而振荡没有开始是因为数值噪音的量随着每步的时间步长变大减小。

通常，仅仅少量的瞬态时间点刚过，时间步长就因为太大而无法产生一个充分的dV/dt来启动振荡器，所以正因为此，振荡器从来不振荡。

为了纠正这种情况，当在起始阶段仿真振荡器时，最大时间步长必须被设定为一个小值，要小到数值噪音可以产生一个充分的dV/dt来启动振荡器。对振荡器的一个好的经验是把最大时间步长设置为振荡周期的$\frac{1}{8}$。

硬盘文件ch5-11b.cir是同样的Colpits振荡器，不过最大时间步长（HMAX）被设置在1/(8*FREQ)，这里FREQ是振荡的自然频率。用下面的命令仿真该电路:

SIM CH5-11B.CIR

你的结果应该和图\ref{图5.11b}匹配。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.11b.png}
    \caption{(b)仿真振荡器会引起时间步长控制问题。通常，这些电路的精确仿真要求限制HMAX参数。（重印自Successfully Simulating Circuits With SPICE。授权使用。）}
    \label{图5.11b}
\end{figure}

设置最大时间步长容许这个仿真来正确预测振荡器的行为。虽然启动振荡需要的最大时间步长随电路的变化而变化，但$\frac{1}{8}$规则通常仍然是一个好的起始值。

即使设置完最大时间步长，一些振荡器电路也会启动失败。对这些电路，把供电电源从0阶梯提升至满值经常会带来成功的启动。图\ref{图5.12}展示了一个CMOS环状振荡器。用下面的命令仿真电路硬盘电路ch5-13a.cir：

SIM CH5-13A.CIR

你的结果应该和图\ref{图5.13a}匹配。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.12.png}
    \caption{电路文件ch5-13.cir的电路原理图。}
    \label{图5.12}
\end{figure}

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.13a.png}
    \caption{(a)（重印自Successfully Simulating Circuits With SPICE。授权使用）}
    \label{图5.13a}
\end{figure}

ch5-13a.cir电路文件是一个反向振荡器（环状振荡器）。该电路使用了七个CMOS反相器的系列组合。注意最大时间步长（HMAX）在电路文件中被手动设置为振荡周期的$\frac{1}{8}$，可是振荡器仍然振荡失败。

在仿真ch5-13a.cir中，电路电源供应被设置为直流5V。在电路文件ch5-13b.cir中，电源供应会在一个PWL电源描述的帮助下阶梯提升。在这个仿真中，电源供应从0到直流5V的转换非常像把电源施加到了一个死电路上。用下面的命令仿真ch5-13b.cir电路：

SIM CH5-13B.CIR

你的结果应该和图\ref{图5.13b}匹配。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.13b.png}
    \caption{(b)除了限制HMAX参数，一些振荡器会要求阶梯提升供电电源以仿真振荡的起始状态。（重印自Successfully Simulating Circuits With SPICE。授权使用）}
    \label{图5.13b}
\end{figure}

偶尔，限制最大时间步长和阶梯提升电源供应仍然无法启动一些顽固的振荡器。一种确定的启动最顽固振荡器电路的方法是使用.IC声明来初始化振荡器环中的一个节点。但是这是初始化振荡的一种手工方法，不会给出振荡器真实的启动过程。

振荡器由于自己天然的本性会引起时间步长控制问题和仿真失效。设置最大时间步长到一个合适的值，阶梯提升电源电压，或者用.IC声明初始化节点全部是振荡器电路仿真瞬态仿真中的重要技术。

\section{插值输出结果 vs 非插值输出结果}
在Berkeley SPICE2G.6中，瞬态仿真输出是从SPICE计算的真实时间点和瞬态声明中（图\ref{图5.1b}）的打印间隔插值而来。Berkeley SPICE2G.6不给用户提供途径获取SPICE求解电路方程的真实时间点。正因为此，SPICE用户必须设置打印间隔为一个小值（这会导致大的输出文件）或者设置打印间隔为一个大值，不过要冒着丢失部分瞬态响应的风险。

在大多数供应商提供的，类SPICE仿真器中，用户被给予了打印SPICE求解电路的真实（非插值的）时间点或者插值输出结果的选择。无论何时只要有可能，强烈推荐SPICE用户查看非插值的瞬态结果。用下面的命令仿真硬盘电路ch5-14a.cir：

SIM CH5-14A.CIR

你的结果应该和图\ref{图5.14a}匹配。现在用下面的命令仿真硬盘电路ch5-14b.cir：

SIM CH5-14B.CIR

你的结果应该和图\ref{图5.14b}匹配。

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.14a.png}
    \caption{(a)（重印自Successfully Simulating Circuits With SPICE。授权使用）}
    \label{图5.14a}
\end{figure}

\begin{figure}[htbp]
\small
    \centering
    \includegraphics[width=0.5\textwidth]{figure/Chapter5/图5.14b.png}
    \caption{(b)插值经常隐藏仿真的精细细节。无论何时只要可能，尽量使用真实的解点（非插值数据）。（重印自Successfully Simulating Circuits With SPICE。授权使用）}
    \label{图5.14b}
\end{figure}

硬盘文件ch5-14b.cir包含了和ch5-14a.cir电路完全一致的列举，只不过加上了RSPICE特定选项NOINTR（.OPTION NOINTR）。这个NOINTR（NO INTeRpolate）选项压制了插值函数，并且打印了RSPICE求解电路方程的真实时间点。用户应该注意这个NOINTR不是一个标准的SPICE选项，而且每个类SPICE仿真器或许会使用一个不同的选项或者命令来压制插值函数。

\section{其他仿真器中的时间步长控制}
\subsection{Hspice}
Hspice使用了一种受知识产权保护的叫作DVDT的时间步长控制算法。这个算法感知电路中的电压水平变化率，并对时间步长做出相应的调整。Hspice也提供标准的局部截断误差和迭代计数时间步长控制算法。

所有这三种算法都可以从以下的提升中获益。第一，Hspice自动把最大时间步长限制为RMAX乘以打印间隔。RMAX是一个用户选择的选项，默认值为2。第二，提高的断点调整减少了Hspice跳过电源断点的机会。

在Hspice中，为了便于以后查看，POST选项迫使仿真器把非插值结果存进一个原始数据文件。如果在选项声明中设置INTRPL，Hspice把插值结果存进原始数据文件。在输出文件中打印的瞬态结果是输出的插值的值。

\subsection{IS\_{Spice}}
IS\_{Spice}使用标准的SPICE2G.6时间步长控制算法。迭代计数和局部截断误差方法是可行的。在IS\_{Spice}中，局部截断误差算法是默认的方法。

IS\_{Spice}在瞬态分析中不提供产生非插值输出结果的机制。

\subsection{Micro-Cap IV}
Micro-Cap IV使用一种修正的局部截断误差时间步长控制算法。这个算法基本上与SPICE中的算法一致，除了另加的提高算法监测电源断点能力的加强。

因为这个提升，Micro-Cap IV不提供迭代计数时间步长控制算法作为用户选择的选项。

在Micro-Cap IV中，仿真器保存和绘制非插值瞬态结果。Micro-Cap IV不产生标准的SPICE输出文件。

\subsection{Pspice}
Pspice使用了一种修正的局部截断误差时间步长控制算法。这个算法基本与SPICE的算法一致，除了另加的两项提高算法表现的加强。第一个加强是无论什么时候使用正弦波电源，对最大时间步长都有一个自动的限制。在Pspice中，最大时间步长被自动限制为1/(8*FREQ)，这里FREQ是电路中任意正弦生成器中的最高频率。第二个加强是在断点计算中变化，该变化确保Pspice不会跳过电源断点。

正因为这些提高，Pspice不提供迭代计数时间步长控制算法作为用户选择的选项。

在Pspice中，为了以后查看，.PROBE声明强迫仿真器把非插值结果存进一个原始数据文件。在输出文件中打印的瞬态结果是标准SPICE的插值结果。

\section{总结}
动态时间步长控制算法极大地提高了瞬态仿真的速度和精度。但是时间步长控制算法不是完美无瑕的，特别是（默认的）局部截断误差。很常见，时间步长对于一个给定的电路响应变得非常大。导致的仿真经常包含了大比例的误差。有时候，时间步长会变得足够大，将完全跳过电路的重要行为。

为了保证高质量仿真结果，SPICE用户需要知道使用哪一个时间步长控制算法，如何在瞬态声明中用HMAX参数手动限制最大时间步长，以及当可行的时候，如何查看非插值瞬态输出结果。

\bibliographystyle{plain}
\bibliography{Reference/chapter5-reference}